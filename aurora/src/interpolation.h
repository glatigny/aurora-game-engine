#ifndef INTERPOLATIONS_H
#define INTERPOLATIONS_H

#define DEFAULT_INTERPOLATION StepInterpolation

#include <stdlib.h>
#include <string.h>
#include <math.h>

/** This class helps calculating intermediate values for many kinds of things.
 * Just use any subclass of Interpolation that suits your needs.
 *
 * Interpolations must be initiated with two points on the interpolation function.
 * Any index can then be generated by interpolating (or extrapolating) from these two points.
 *
 * This class should be used as much as possible for many reasons :
 *  It is fully inlined for highest possible speed.
 *  Someday, an implementation using DSP instructions may appear on specific plateforms.
 */
// QC:P
class Interpolation {
protected:
	/** Sets an interpolation parameter.
	 * @param parameter the identifier of the parameter. Values and effects differ for each interpolator.
	 * @param value the value of the parameter.
	 */
	virtual void setParameter(unsigned int parameter, int value) {}

public:
	virtual ~Interpolation() {}

	/** Sets interpolation points.
	 * @param startIndex the initial starting index.
	 * @param endIndex the initial ending index.
	 * @param startValue the value at the initial starting index.
	 * @param endValue the value at the initial ending index.
	 * @param clip when enabled, the interpolation always returns startValue for indexes before startIndex and endValue for indexes after endIndex.
	 */
	virtual void set(int startIndex, int endIndex, int startValue, int endValue, bool clip) = 0;

	/** Sets parameters read from a string.
	 * Example of string : "3:25:1:12:50" will push 3 in the parameter 0, 25 in the parameter 1, etc.
	 * The default implementation will call setParameter.
	 * This function may be overridden by any sub-class of Interpolation, the format of the string is allowed to change.
	 * @param parameterValues a string containing the list of values separated by a column.
	 */
	// QC:P
	virtual void setParameters(const char* parameterValues) {
		int p = 0;
		while(parameterValues && *parameterValues && *parameterValues >= '0' && *parameterValues <= '9') {
			setParameter(p++, atoi(parameterValues));
			parameterValues = strchr(parameterValues, ':');
			if(parameterValues) {
				parameterValues++;
			}
		}
	}

	/** Returns the interpolated value based on given index.
	 * @param index the index from where to fetch the value.
	 * @return the interpolated value computed at the given index.
	 */
	virtual int getInterpolatedValue(int index) = 0;
};

// QC:P
class StepInterpolation : public Interpolation {
private:
	int startIndex;
	int endIndex;
	int stepIndex;
	int startValue;
	int endValue;
	int stepPercent;

protected:
	// QC:?
	void setParameter(unsigned int parameter, int value) {
		assert(parameter == 0);

		assert(value >= 0 && value <= 100);
		stepPercent = value;

		stepIndex = endIndex*stepPercent/100 + startIndex*(100-stepPercent)/100;
	}


public:
	StepInterpolation(): stepPercent(100) {}
	~StepInterpolation() {}

	// QC:G
	void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		startIndex = newStartIndex;
		endIndex = newEndIndex;
		stepIndex = newEndIndex*stepPercent/100 + newStartIndex*(100-stepPercent)/100;
		startValue = newStartValue;
		endValue = newEndValue;
	}

	// QC:P
	int getInterpolatedValue(int index) {
		return index >= stepIndex ? endValue : startValue;
	}
};

// QC:P
class LinearInterpolation : public Interpolation {
private:
	int minValue;
	int maxValue;
	int slopeNum;
	int slopeDenom;
	int zeroValue;
	bool clip;

public:
	virtual ~LinearInterpolation() {}

	// QC:P
	virtual void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		minValue = MIN(newStartValue, newEndValue);
		maxValue = MAX(newStartValue, newEndValue);
		slopeNum = newEndValue - newStartValue;
		slopeDenom = newEndIndex - newStartIndex;
		zeroValue = newStartValue - newStartIndex * slopeNum / slopeDenom;
		clip = newClip;
	}

	// QC:P
	virtual int getInterpolatedValue(int index) {
		if(clip) {
			int value = zeroValue + index * slopeNum / slopeDenom;
			return MIN(MAX(value, minValue), maxValue);
		}

		return zeroValue + index * slopeNum / slopeDenom;
	}
};

// QC:W (Still linear)
class QuadInterpolation : public Interpolation {
private:
	int minValue;
	int maxValue;
	int slopeNum;
	int slopeDenom;
	int zeroValue;
	bool clip;

public:
	virtual ~QuadInterpolation() {}

	// QC:W
	virtual void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		minValue = MIN(newStartValue, newEndValue);
		maxValue = MAX(newStartValue, newEndValue);
		slopeNum = newEndValue - newStartValue;
		slopeDenom = newEndIndex - newStartIndex;
		zeroValue = newStartValue - newStartIndex * slopeNum / slopeDenom;
		clip = newClip;
	}

	// QC:W
	virtual int getInterpolatedValue(int index) {
		if(clip) {
			int value = zeroValue + index * slopeNum / slopeDenom;
			return MIN(MAX(value, minValue), maxValue);
		}

		return zeroValue + index * slopeNum / slopeDenom;
	}
};

// QC:S
class SinusInterpolation : public Interpolation {
private:
	int startIndex;
	int endIndex;
	int startValue;
	int endValue;
	int quarters;
	int offset;
	bool clip;

public:
	SinusInterpolation() : quarters(2), offset(-1) {}
	virtual ~SinusInterpolation() {}

	// QC:?
	virtual void setParameter(unsigned int parameter, int value) {
		assert(parameter <= 1);
		if(!parameter) {
			// Parameter 0 = quarters
			assert(value >= 1);
			quarters = value;
		} else {
			// Parameter 1 = offset
			offset = value;
		}
	}

	// QC:?
	virtual void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		startIndex = newStartIndex;
		endIndex = newEndIndex;
		startValue = newStartValue;
		endValue = newEndValue;
		clip = newClip;
	}

	// QC:S (may not be optimal but works well)
	virtual int getInterpolatedValue(int index) {
		if(clip) {
			if(startIndex < endIndex) {
				if(index < startIndex) {
					return startValue;
				} else if(index > endIndex) {
					return endValue;
				}
			} else {
				if(index > startIndex) {
					return startValue;
				} else if(index < endIndex) {
					return endValue;
				}
			}
		}

		float sinVal = sinf((M_PI_2*offset) + (M_PI_2*quarters) * (
													(float)(index-startIndex)
													/
													(float)(endIndex-startIndex)
												)) / 2 + 0.5;
		return startValue + (int)((endValue-startValue)*sinVal);
	}

};


// QC:?
class HalfSinusInterpolation : public Interpolation {
private:
	int startIndex;
	int endIndex;
	int startValue;
	int endValue;
	bool clip;

public:
	virtual ~HalfSinusInterpolation() {}

	// QC:P
	virtual void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		startIndex = newStartIndex;
		endIndex = newEndIndex;
		startValue = newStartValue;
		endValue = newEndValue;
		clip = newClip;
	}

	// QC:S (may not be optimal but works well)
	virtual int getInterpolatedValue(int index) {
		if(clip) {
			if(startIndex < endIndex) {
				if(index < startIndex) {
					return startValue;
				} else if(index > endIndex) {
					return endValue;
				}
			} else {
				if(index > startIndex) {
					return startValue;
				} else if(index < endIndex) {
					return endValue;
				}
			}
		}

		float sinVal = sinf((float)(index-startIndex)*M_PI_2/abs(endIndex-startIndex));
		return startValue + (int)((endValue-startValue)*sinVal);
	}

};



// QC:?
class SincInterpolation : public Interpolation {
private:
	int startIndex;
	int endIndex;
	int startValue;
	int endValue;
	int oscillations;
	bool clip;

public:
	SincInterpolation() : oscillations(1) {}
	virtual ~SincInterpolation() {}

	// QC:P
	virtual void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		startIndex = newStartIndex;
		endIndex = newEndIndex;
		startValue = newStartValue;
		endValue = newEndValue;
		clip = newClip;
	}

	// QC:P
	virtual void setParameter(unsigned int parameter, int value) {
		assert(parameter <= 0);
		if(!parameter) {
			// Parameter 0 = oscillations
			assert(value >= 1);
			oscillations = value;
		}
	}

	// QC:S (may not be optimal but works well)
	virtual int getInterpolatedValue(int index) {
		if(clip) {
			if(startIndex < endIndex) {
				if(index < startIndex) {
					return startValue;
				} else if(index > endIndex) {
					return endValue;
				}
			} else {
				if(index > startIndex) {
					return startValue;
				} else if(index < endIndex) {
					return endValue;
				}
			}
		}

		// Normalize x
		float x = (index - startIndex) / (float)(endIndex - startIndex);

		// Compute sinc in normalized space
		float sinVal = 1 - (sinf(oscillations*M_PI*x) / (oscillations*M_PI*x)) * (1-pow(x, oscillations));

		// Apply result
		return startValue + (int)((endValue-startValue)*sinVal);
	}

};



// QC:P
class RandomInterpolation : public Interpolation {
private:
	int startIndex;
	int indexDelta;
	int startValue;
	int endValue;

public:
	virtual ~RandomInterpolation() {}

	// QC:P
	virtual void set(int newStartIndex, int newEndIndex, int newStartValue, int newEndValue, bool newClip) {
		startIndex = newStartIndex;
		indexDelta = newEndIndex - newStartIndex;
		startValue = newStartValue;
		endValue = newEndValue;
	}

	// QC:P
	virtual int getInterpolatedValue(int index) {
		return randomDouble()<((double)(index-startIndex))/indexDelta ? endValue : startValue;
	}
};

/*class FrameInterpolation : public Interpolation {
};*/


/** This function generates interpolation functions based on their name.
 * @param name the name of the interpolation function.
 * @return an instance of the interpolation function or NULL if the name is invalid or if the function is unknown.
 */
Interpolation* newInterpolation(const char* name);

#endif

